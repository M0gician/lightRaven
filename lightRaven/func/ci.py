import numpy as np
from numba import njit, prange
from scipy import stats, optimize


# @njit(parallel=True, fastmath=True)
@njit(fastmath=True)
def _t_interval(sample: np.ndarray, t: float, ref_size, c, mode) -> float:
    """
    A generic function wrapper for calculating concentration lower bounds

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    t : float
        t statistics at given data size and significance level
    ref_size : (int, optional)
        Size of the safety dataset
    c : float
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    mode : str
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration range using Student's t-test given the sample and significance level

    :param sample: np.ndarray
    :param t: float
    :param ref_size: int
    :param c: float
    :param mode: str
    :return: float
    """
    data_size = sample.shape[0]
    sample_mean = np.mean(sample)
    sample_variance = np.sum((sample - sample_mean) ** 2) / (data_size - 1)
    sample_std = np.sqrt(sample_variance)

    if mode == "one":
        interval = t * sample_std / np.sqrt(ref_size)
    elif mode == "two":
        interval = t * sample_std / np.sqrt(ref_size)
    else:
        raise ValueError(f"mode can only be \"one\" or \"two\".")

    return c * interval


# @njit(parallel=True, fastmath=True)
@njit(fastmath=True)
def _hoeffding_interval(sample: np.ndarray, ref_size, c, delta, mode) -> float:
    """
    A helper function calculates the concentration interval using Hoeffding inequality.
    No assumptions over the sampled distribution.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : float
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : float
        The significance level.
    mode : str
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration range using Hoeffding's inequality given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    b = np.max(sample) - np.min(sample)

    if mode == "one":
        interval = b * np.sqrt(np.log(1 / delta) / (2 * ref_size))
    elif mode == "two":
        interval = b * np.sqrt(np.log(2 / delta) / (2 * ref_size))
    else:
        raise ValueError(f"mode can only be \"one\" or \"two\".")

    return c * interval


@njit(parallel=True, fastmath=True)
def _mpeb_interval(sample: np.ndarray, ref_size, c, delta, mode) -> float:
    """
    A helper function calculates the concentration interval using Maurer-Pontil Empirical Bernstein Bound.
    No assumptions over the sampled distribution.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : float
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : float
        The significance level.
    mode : str
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration range using Maurer-Pontil Empirical Bernstein Bound given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    data_size = sample.shape[0]
    b = np.max(sample) - np.min(sample)

    diff_sum = 0.0
    for x_i in prange(data_size):
        diff_sum += np.sum((sample[x_i] - sample) ** 2)

    if mode == "one":
        interval_1 = (7 * b * np.log(2 / delta)) / (3 * ref_size - 3)
        interval_2 = np.sqrt(
            (np.log(2 / delta) * diff_sum) / (ref_size - 1)
        ) / ref_size
    elif mode == "two":
        interval_1 = (7 * b * np.log(2 / (delta / 2))) / (3 * ref_size - 3)
        interval_2 = np.sqrt(
            2.0 * (np.log(2 / delta) * diff_sum) / (ref_size - 1)
        ) / ref_size
    else:
        raise ValueError(f"mode can only be \"one\" or \"two\".")

    return c * (interval_1 + interval_2)


@njit(parallel=True, fastmath=True)
def _mcma(sample: np.ndarray, ref_size, c, delta, mode, mc_size) -> float:
    """
    A function calculates the 1-delta percentile of the sample using Monte-Carlo M_alpha method.
    No assumptions over the sampled distribution.

    For more details, please check the paper:
        "A New Confidence Interval for the Mean of a Bounded Random Variable"
        https://arxiv.org/pdf/1905.06208.pdf

    Parameters
    ----------
    sample : np.ndarray
        The sample data
    ref_size : (int, optional)
        [NOT USED] Size of the safety dataset
    c : float
        [NOT USED] A hyperparameter used to scale the concentration interval generated by `ci_ub`.
    delta : float
        The significance level.
    mode : str
        [NOT USED] "one" for one-sided test; "two" for two-sided test
    mc_size : int
        The sample size for Monte Carlo estimation

    Returns
    ----------
    float: The percentile using Monte-Carlo M_alpha given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :param mc_size: int
    :return: float
    """
    if mode == "two":
        delta /= 2

    mc_size = int(mc_size)
    n = sample.shape[0]
    z = np.sort(sample).astype(np.float64)
    s_prime = np.ones(n)
    s_prime[:-1] = z[1:]
    s = s_prime - z

    u = np.random.uniform(0, 1, (mc_size, n))
    for idx in prange(mc_size):
        u[idx] = np.sort(u[idx])
    ms = 1.0 - (u @ s)
    ms = np.sort(ms.ravel())

    return ms[int(np.ceil((1-delta) * mc_size))]


def t_lb(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode='one') -> float:
    """
    A function calculates the lower bound using student-t distribution.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : (float, optional)
        The significance level.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration lower bound using Student's t-test given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    reference_size = sample.shape[0] if ref_size is None else ref_size
    interval_correction = 1 if c is None else c

    t = 0.0
    if mode == "one":
        t = stats.t.ppf(1 - delta, reference_size - 1)
    elif mode == "two":
        t = stats.t.ppf(1 - delta / 2, reference_size - 1)

    sample_mean = np.mean(sample)
    interval = _t_interval(sample, t, reference_size, interval_correction, mode)

    return sample_mean - interval


def t_ub(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode='one') -> float:
    """
    A function calculates the upper bound using student-t distribution.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : (float, optional)
        The significance level.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration upper bound using Student's t-test given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    reference_size = sample.shape[0] if ref_size is None else ref_size
    interval_correction = 1 if c is None else c

    t = 0.0
    if mode == "one":
        t = stats.t.ppf(1 - delta, reference_size - 1)
    elif mode == "two":
        t = stats.t.ppf(1 - delta / 2, reference_size - 1)

    sample_mean = np.mean(sample)
    interval = _t_interval(sample, t, reference_size, interval_correction, mode)

    return sample_mean + interval


@njit(parallel=True, fastmath=True)
def hoeffding_lb(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode="one"):
    """
    A function calculates the lower bound using Hoeffding inequality.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : (float, optional)
        The significance level.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration lower bound using Hoeffding inequality given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    ref_size = sample.shape[0] if ref_size is None else ref_size
    c = 1 if c is None else c

    sample_mean = np.mean(sample)
    interval = _hoeffding_interval(sample, ref_size, c, delta, mode)

    return sample_mean - interval


@njit(parallel=True, fastmath=True)
def hoeffding_ub(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode="one"):
    """
    A function calculates the lower bound using Hoeffding inequality.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : (float, optional)
        The significance level.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration upper bound using Hoeffding inequality given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    ref_size = sample.shape[0] if ref_size is None else ref_size
    c = 1 if c is None else c

    sample_mean = np.mean(sample)
    interval = _hoeffding_interval(sample, ref_size, c, delta, mode)

    return sample_mean + interval


@njit(parallel=True, fastmath=True)
def mpeb_lb(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode="one"):
    """
    A  function calculates the lower bound using Maurer-Pontil Empirical Bernstein Bounds.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : (float, optional)
        The significance level.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration lower bound using Maurer-Pontil Empirical Bernstein Bounds
           given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    ref_size = sample.shape[0] if ref_size is None else ref_size
    c = 1 if c is None else c

    sample_mean = np.mean(sample)
    interval = _mpeb_interval(sample, ref_size, c, delta, mode)

    return sample_mean - interval


@njit(parallel=True, fastmath=True)
def mpeb_ub(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode="one"):
    """
    A  function calculates the upper bound using Maurer-Pontil Empirical Bernstein Bounds.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : (float, optional)
        The significance level.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration upper bound using Maurer-Pontil Empirical Bernstein Bounds
           given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    ref_size = sample.shape[0] if ref_size is None else ref_size
    c = 1 if c is None else c

    sample_mean = np.mean(sample)
    interval = _mpeb_interval(sample, ref_size, c, delta, mode)

    return sample_mean + interval


@njit
def mcma_lb(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode=None, mc_size=10000) -> float:
    """
    A function calculates the lower bound using Monte-Carlo M_alpha method.

    For more details, please check the paper:
        "A New Confidence Interval for the Mean of a Bounded Random Variable"
        https://arxiv.org/pdf/1905.06208.pdf

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test
    delta : (float, optional)
        The significance level.
    mc_size : int
        The sample size for Monte Carlo estimation

    Returns
    ----------
    float: The concentration lower bound using Monte-Carlo M_alpha given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param mode: str
    :param delta: float
    :param mc_size: int
    :return: float
    """
    return _mcma(sample, ref_size, c, 1-delta, mode, mc_size)


@njit(fastmath=True)
def anderson_ub(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode="one") -> float:
    """
    A function calculates the upper concentration bound using Anderson inequality.
    No assumptions over the sampled distribution.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : float
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : float
        The significance level.
    mode : str
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration range using Anderson Bound given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    if mode == "two":
        delta /= 2
    ref_size = sample.shape[0] if ref_size is None else ref_size
    c = 1.0 if c is None else c

    ordered_sample = np.sort(sample)
    n = ordered_sample.shape[0]

    z_n = ordered_sample[-1]
    z_shifted = np.zeros(n)
    z_shifted[1:] = ordered_sample[:-1]
    z = ordered_sample - z_shifted

    for i in prange(n):
        z_shifted[i] = np.maximum(0.0, i / ref_size - np.sqrt(np.log(2 / delta) / (2 * ref_size)))

    return c * (z_n - z @ z_shifted)


@njit(fastmath=True)
def anderson_lb(sample: np.ndarray, ref_size=None, c=None, delta=0.05, mode="one") -> float:
    """
    A helper function calculates the concentration interval using Anderson inequality.
    No assumptions over the sampled distribution.

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : float
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    delta : float
        The significance level.
    mode : str
        "one" for one-sided test; "two" for two-sided test

    Returns
    ----------
    float: The concentration range using Anderson Bound given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param delta: float
    :param mode: str
    :return: float
    """
    if mode == "two":
        delta /= 2
    ref_size = sample.shape[0] if ref_size is None else ref_size
    c = 1.0 if c is None else c

    ordered_sample = np.sort(sample)
    n = ordered_sample.shape[0]

    z_n = ordered_sample[-1]
    z_shifted = np.zeros(n)
    z_shifted[1:] = ordered_sample[:-1]
    z = ordered_sample - z_shifted

    for i in prange(n):
        z_shifted[i] = np.minimum(1.0, i / ref_size + np.sqrt(np.log(2 / delta) / (2 * ref_size)))

    return c * (z_n - z @ z_shifted)


@njit
def mcma_ub(sample: np.ndarray, ref_size=None, c=None, mode=None, delta=0.05, mc_size=10000) -> float:
    """
    A function calculates the upper bound using Monte-Carlo M_alpha method.

    For more details, please check the paper:
        "A New Confidence Interval for the Mean of a Bounded Random Variable"
        https://arxiv.org/pdf/1905.06208.pdf

    Parameters
    ----------
    sample : np.ndarray
        Sample data
    ref_size : (int, optional)
        Size of the safety dataset
    c : (float, optional)
        A hyperparameter used to scale the concentration interval generated by `ci_ub`.
        For student t, use `2` in candidate selection; Otherwise use `1`.
    mode : (str, optional)
        "one" for one-sided test; "two" for two-sided test
    delta : (float, optional)
        The significance level.
    mc_size : int
        The sample size for Monte Carlo estimation

    Returns
    ----------
    float: The concentration upper bound using Monte-Carlo M_alpha given the sample and significance level

    :param sample: np.ndarray
    :param ref_size: int
    :param c: float
    :param mode: str
    :param delta: float
    :param mc_size: int
    :return: float
    """
    return _mcma(sample, ref_size, c, delta, mode, mc_size)


if __name__ == "__main__":
    # pop = np.random.randn(100)
    pop = np.random.geometric(0.35, 1000)
    sample = np.random.choice(pop, 200)
    sample_prime = (sample - sample.min()) / (sample.max() - sample.min())
    s_sum = sample_prime.sum()
    s_mean = sample_prime.mean()
    s_squared = 0
    for i in range(sample_prime.size):
        s_squared += sample_prime[i] * sample_prime[i]
    print(f"{s_sum} {s_mean} {s_squared}")
    print(f"mean: {sample.mean()}; size: {sample.size}, b: {sample.max()}, a: {sample.min()}")
    print(f"    MC Ma CI: [{mcma_lb(sample)}, {mcma_ub(sample)}]")
    print(f"Student t CI: [{t_lb(sample, c=2)}, {t_ub(sample, c=2)}]")
    print(f"Hoeffding CI: [{hoeffding_lb(sample, c=1)}, {hoeffding_ub(sample, c=1)}]")
    print(f" Anderson CI: [{anderson_lb(sample, c=1)}, {anderson_ub(sample, c=1)}]")
    print(f"     MPeB CI: [{mpeb_lb(sample, c=1)}, {mpeb_ub(sample, c=1)}]")
    # print(f"  extMPeB CI: [{extMPeB_lb(sample, correction=1)}, {extMPeB_ub(sample, correction=1)}]")
